#!/usr/bin/env python3
"""Regenerate THIRD-PARTY-NOTICES.txt.

Concatenates the static C++ header (scripts/notices-header.txt) with an
auto-generated Python section produced by pip-licenses.

Only runtime dependencies are included — dev-only packages are excluded
by resolving the runtime dependency tree from the lockfile via ``uv export``.
Platform-specific packages (with environment markers) are excluded so the
output is identical on every OS.

Usage:
    uv run scripts/update-notices.py          # regenerate the file
    uv run scripts/update-notices.py --check  # exit 1 if file is stale
"""

from __future__ import annotations

import json
import subprocess
import sys
from pathlib import Path

ROOT = Path(__file__).resolve().parent.parent
HEADER = ROOT / "scripts" / "notices-header.txt"
OUTPUT = ROOT / "THIRD-PARTY-NOTICES.txt"
MCPSERVER = ROOT / "Wrapping" / "Python" / "MCPServer"

SELF_PACKAGES = frozenset({"paraview-mcp-server", "paraview-mcp"})


def _get_runtime_package_names() -> set[str]:
    """Resolve the runtime dependency tree and return normalized names.

    Uses ``uv export`` to read from the lockfile for deterministic resolution
    across platforms.  Packages with environment markers (e.g. ``; sys_platform
    == 'win32'``) are excluded so the output is identical on every OS.
    """
    result = subprocess.run(
        ["uv", "export", "--no-dev", "--no-hashes", "--no-header"],
        capture_output=True,
        text=True,
        check=True,
        cwd=MCPSERVER,
    )
    names: set[str] = set()
    for line in result.stdout.splitlines():
        line = line.strip()
        if not line or line.startswith("#") or line.startswith("-e"):
            continue
        # Skip platform-specific packages (lines with environment markers)
        if ";" in line:
            continue
        if "==" in line:
            names.add(line.split("==")[0].strip().lower())
    return names


def get_python_licenses() -> list[dict[str, str]]:
    """Run pip-licenses and return license data for runtime packages only."""
    runtime_names = _get_runtime_package_names()

    result = subprocess.run(
        [
            "uv",
            "run",
            "pip-licenses",
            "--format=json",
            "--with-license-file",
            "--no-license-path",
        ],
        capture_output=True,
        text=True,
        check=True,
        cwd=MCPSERVER,
    )
    packages = json.loads(result.stdout)
    return sorted(
        [
            p
            for p in packages
            if p["Name"].lower() in runtime_names and p["Name"] not in SELF_PACKAGES
        ],
        key=lambda p: p["Name"].lower(),
    )


def build_python_section(packages: list[dict[str, str]]) -> str:
    """Format the Python dependencies section."""
    lines = [
        "========================================================================",
        "Python Dependencies (auto-generated — do not edit by hand)",
        "========================================================================",
        "",
        "The paraview-mcp-server Python package depends on the following",
        "libraries, all distributed under permissive licenses.",
        "",
        "Generated by: uv run scripts/update-notices.py",
        "",
    ]
    for pkg in packages:
        name = pkg["Name"]
        version = pkg["Version"]
        license_id = pkg["License"]
        license_text = pkg.get("LicenseText", "").strip()

        lines.append(
            "------------------------------------------------------------------------"
        )
        lines.append(f"{name} {version} ({license_id})")
        lines.append(
            "------------------------------------------------------------------------"
        )
        if license_text and license_text != "UNKNOWN":
            lines.append("")
            # Strip trailing whitespace per line to match pre-commit hooks.
            for line in license_text.splitlines():
                lines.append(line.rstrip())
        lines.append("")
    return "\n".join(lines)


def generate() -> str:
    """Build the full THIRD-PARTY-NOTICES.txt content."""
    header = HEADER.read_text()
    packages = get_python_licenses()
    python_section = build_python_section(packages)
    return header + "\n" + python_section


def main() -> int:
    check_only = "--check" in sys.argv

    content = generate()

    if check_only:
        if not OUTPUT.exists():
            print(
                "THIRD-PARTY-NOTICES.txt does not exist. Run: uv run scripts/update-notices.py"
            )
            return 1
        current = OUTPUT.read_text()
        if current != content:
            print("THIRD-PARTY-NOTICES.txt is out of date.")
            print("Run: uv run scripts/update-notices.py")
            return 1
        print("THIRD-PARTY-NOTICES.txt is up to date.")
        return 0

    OUTPUT.write_text(content)
    print(f"Updated {OUTPUT.relative_to(ROOT)}")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
